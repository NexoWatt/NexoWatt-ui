<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NexoWatt – Lizenz Generator (intern)</title>
  <style>
    :root{
      --bg: #0b1220;
      --panel: rgba(2,6,23,0.55);
      --border: rgba(148,163,184,0.22);
      --txt: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.64);
      --accent: #22c55e;
      --danger: #ef4444;
    }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
      background: radial-gradient(1200px 600px at 30% 0%, rgba(30,58,138,0.25), transparent 55%),
                  radial-gradient(900px 500px at 90% 20%, rgba(14,116,144,0.18), transparent 60%),
                  var(--bg);
      color: var(--txt);
    }
    .wrap{ max-width: 980px; margin: 0 auto; padding: 28px 22px; }
    h1{ margin: 0 0 8px; font-size: 1.25rem; letter-spacing: 0.2px; }
    .sub{ margin: 0 0 18px; color: var(--muted); font-size: 0.95rem; line-height: 1.4; }
    .card{
      border: 1px solid var(--border);
      border-radius: 16px;
      background: var(--panel);
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      padding: 18px;
    }
    .grid{ display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 860px){ .grid{ grid-template-columns: 1fr 1fr; } }
    label{ display:block; font-size: 0.85rem; color: var(--muted); margin-bottom: 6px; }
    .row{ display:flex; gap: 10px; align-items:center; }
    input{
      width:100%;
      border: 1px solid var(--border);
      background: rgba(2,6,23,0.35);
      color: var(--txt);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
      font-size: 0.95rem;
    }
    input:focus{ border-color: rgba(34,197,94,0.65); box-shadow: 0 0 0 3px rgba(34,197,94,0.18); }
    input[readonly]{ opacity: 0.92; }
    .btn{
      appearance:none;
      border: 1px solid var(--border);
      background: rgba(2,6,23,0.45);
      color: var(--txt);
      border-radius: 12px;
      padding: 10px 14px;
      cursor:pointer;
      font-weight: 600;
      white-space: nowrap;
    }
    .btn:hover{ border-color: rgba(34,197,94,0.65); }
    .btn--primary{ border-color: rgba(34,197,94,0.55); background: rgba(34,197,94,0.10); }
    .hint{ margin-top: 10px; font-size: 0.85rem; color: var(--muted); line-height: 1.4; }
    .status{ margin-top: 12px; font-weight: 700; font-size: 0.95rem; }
    .ok{ color: var(--accent); }
    .bad{ color: var(--danger); }
    code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.92rem; }
    .small{ font-size: 0.85rem; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>NexoWatt – Lizenz Generator (intern)</h1>
    <p class="sub">
      UUID → Lizenzschlüssel (HMAC‑SHA256, <code>NW1-....</code>). Dieses Tool ist für Support/Vertrieb gedacht.
      <br/>Hinweis: Der Secret‑String ist im Source enthalten – bitte vor Public‑Releases anpassen.
    </p>

    <div class="card">
      <div class="grid">
        <div>
          <label>ioBroker UUID</label>
          <div class="row">
            <input id="uuid" type="text" placeholder="z. B. 12345678-90ab-cdef-1234-567890abcdef" />
            <button class="btn" id="btnPaste">Einfügen</button>
            <button class="btn" id="btnClear">Leeren</button>
          </div>
          <div class="hint">
            UUID bekommst du z. B. aus der ioBroker‑Admin Lizenzseite (System‑UUID) oder aus <code>system.meta.uuid</code>.
          </div>
        </div>

        <div>
          <label>Generierter Lizenzschlüssel</label>
          <div class="row">
            <input id="key" type="text" readonly value="" />
            <button class="btn btn--primary" id="btnCopy">Kopieren</button>
          </div>
          <div class="hint" id="hintAlgo"></div>
        </div>
      </div>

      <div class="status" id="status"></div>
    </div>
  </div>

  <script>
    // IMPORTANT: Must match the secret in main.js (_nwExpectedLicenseKey) + scripts/gen-license.js
    const secret = 'nw_lis_salt_v1 change me';

    const elUuid = document.getElementById('uuid');
    const elKey = document.getElementById('key');
    const elStatus = document.getElementById('status');
    const elAlgo = document.getElementById('hintAlgo');

    function setStatus(text, ok){
      elStatus.textContent = text || '';
      elStatus.className = 'status ' + (ok ? 'ok' : 'bad');
    }

    // Optional: prefill UUID from query string (?uuid=...)
    try {
      const qs = new URLSearchParams(window.location.search);
      const qUuid = (qs.get('uuid') || '').trim();
      if (qUuid) elUuid.value = qUuid;
    } catch(_e) {
      // ignore
    }

    // --- Minimal SHA-256 + HMAC (no external deps; works on http/file) ---
    function rightRotate(value, amount){
      return (value >>> amount) | (value << (32 - amount));
    }
    function sha256(ascii){
      const mathPow = Math.pow;
      const maxWord = mathPow(2, 32);
      const lengthProperty = 'length';
      let i, j;

      const words = [];
      const asciiBitLength = ascii[lengthProperty] * 8;
      let hash = sha256.h = sha256.h || [];
      let k = sha256.k = sha256.k || [];
      let primeCounter = k[lengthProperty];
      const isComposite = {};

      for (let candidate = 2; primeCounter < 64; candidate++) {
        if (!isComposite[candidate]) {
          for (i = 0; i < 313; i += candidate) isComposite[i] = candidate;
          hash[primeCounter] = (mathPow(candidate, 0.5) * maxWord) | 0;
          k[primeCounter++] = (mathPow(candidate, 1 / 3) * maxWord) | 0;
        }
      }

      ascii += '\x80';
      while (ascii[lengthProperty] % 64 - 56) ascii += '\x00';
      for (i = 0; i < ascii[lengthProperty]; i++) {
        j = ascii.charCodeAt(i);
        if (j >> 8) throw new Error('SHA256: only supports byte strings (0..255).');
        words[i >> 2] |= j << (((3 - i) % 4) * 8);
      }
      words[words[lengthProperty]] = (asciiBitLength / maxWord) | 0;
      words[words[lengthProperty]] = asciiBitLength;

      for (j = 0; j < words[lengthProperty];) {
        const w = words.slice(j, (j += 16));
        const oldHash = hash;
        hash = hash.slice(0, 8);

        for (i = 0; i < 64; i++) {
          const w15 = w[i - 15], w2 = w[i - 2];
          const a = hash[0], e = hash[4];
          const temp1 =
            hash[7] +
            (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) +
            ((e & hash[5]) ^ (~e & hash[6])) +
            k[i] +
            (w[i] =
              i < 16
                ? w[i]
                : (w[i - 16] +
                    (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3)) +
                    w[i - 7] +
                    (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10))) |
                  0);
          const temp2 =
            (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) +
            ((a & hash[1]) ^ (a & hash[2]) ^ (hash[1] & hash[2]));

          hash = [
            (temp1 + temp2) | 0,
            a,
            hash[1],
            hash[2],
            (hash[3] + temp1) | 0,
            e,
            hash[5],
            hash[6]
          ];
        }

        for (i = 0; i < 8; i++) hash[i] = (hash[i] + oldHash[i]) | 0;
      }

      let result = '';
      for (i = 0; i < 8; i++) {
        for (j = 3; j + 1; j--) {
          const b = (hash[i] >> (j * 8)) & 255;
          result += (b < 16 ? '0' : '') + b.toString(16);
        }
      }
      return result;
    }
    function strToBytes(str){
      const out = [];
      for (let i = 0; i < str.length; i++) out.push(str.charCodeAt(i) & 0xff);
      return out;
    }
    function bytesToStr(bytes){
      let s = '';
      for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
      return s;
    }
    function hexToBytes(hex){
      const out = [];
      for (let i = 0; i < hex.length; i += 2) out.push(parseInt(hex.slice(i, i + 2), 16));
      return out;
    }
    function hexToBytesStr(hex){
      return bytesToStr(hexToBytes(hex));
    }
    function hmacSha256(key, msg){
      const blockSize = 64;
      let keyBytes = strToBytes(String(key || ''));
      if (keyBytes.length > blockSize) {
        keyBytes = hexToBytes(sha256(bytesToStr(keyBytes)));
      }
      while (keyBytes.length < blockSize) keyBytes.push(0);

      const oKeyPad = keyBytes.map((b) => b ^ 0x5c);
      const iKeyPad = keyBytes.map((b) => b ^ 0x36);

      const innerHex = sha256(bytesToStr(iKeyPad) + String(msg || ''));
      const outerHex = sha256(bytesToStr(oKeyPad) + hexToBytesStr(innerHex));
      return outerHex;
    }

    function generate(uuid){
      const u = String(uuid || '').trim();
      if (!u) return '';
      const hex = hmacSha256(secret, u).toUpperCase();
      const core = hex.slice(0, 32);
      const groups = core.match(/.{1,4}/g) || [core];
      return 'NW1-' + groups.join('-');
    }

    function refresh(){
      try {
        const u = (elUuid.value || '').trim();
        const key = generate(u);
        elKey.value = key;
        if (!u) {
          setStatus('', true);
          elAlgo.textContent = 'Algorithmus: HMAC‑SHA256(secret, uuid) → Hex → 32 Zeichen → NW1-xxxx-...';
          return;
        }
        if (!key) {
          setStatus('UUID ungültig oder leer.', false);
          return;
        }
        setStatus('Bereit ✅', true);
        elAlgo.innerHTML = 'Secret: <code>' + secret.replace(/</g,'&lt;') + '</code><br/>Format: <code>NW1-</code> + 32 Hex‑Zeichen (8 Gruppen à 4)';
      } catch (e) {
        setStatus('Fehler: ' + (e && e.message ? e.message : String(e)), false);
      }
    }

    elUuid.addEventListener('input', refresh);

    document.getElementById('btnCopy').addEventListener('click', async () => {
      const v = String(elKey.value || '').trim();
      if (!v) return;
      try{
        await navigator.clipboard.writeText(v);
        setStatus('Lizenzschlüssel kopiert ✅', true);
      } catch(e){
        setStatus('Kopieren nicht möglich – bitte manuell markieren.', false);
      }
    });

    document.getElementById('btnClear').addEventListener('click', () => {
      elUuid.value = '';
      elKey.value = '';
      refresh();
    });

    document.getElementById('btnPaste').addEventListener('click', async () => {
      try{
        const t = await navigator.clipboard.readText();
        if (t) elUuid.value = t.trim();
        refresh();
      } catch(e){
        setStatus('Einfügen nicht möglich – bitte manuell einfügen.', false);
      }
    });

    refresh();
  </script>
</body>
</html>
